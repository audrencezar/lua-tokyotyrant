<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="../luadoc.css" type="text/css" />
	<!--meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/-->
</head>

<body>
<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->

<div id="main">

<div id="navigation">


<h1>LuaDoc</h1>
<ul>
	
	<li><a href="../index.html">Index</a></li>
	
</ul>


<!-- Module list -->

<h1>Modules</h1>
<ul>

	<li><strong>tokyotyrant</strong></li>
	
</ul>



<!-- File list -->






</div><!-- id="navigation" -->

<div id="content">

<h1>Module <code>tokyotyrant</code></h1>

<p>lua-tokyotyrant</p>





<h2>Functions</h2>
<table class="function_list">

	<tr>
	<td class="name" nowrap><a href="#RDB.keys">RDB.keys</a>&nbsp;()</td>
	<td class="summary">return an array of all keys </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB.values">RDB.values</a>&nbsp;()</td>
	<td class="summary">return an array of all values </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:adddouble">RDB:adddouble</a>&nbsp;(key, num)</td>
	<td class="summary">add a real number to a record if record exists, it is treated as a real number and added to else a new record is created with the provided value records are stored in binary format, and must be unpacked upon retrieval </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:addint">RDB:addint</a>&nbsp;(key, num)</td>
	<td class="summary">add an integer to a record if record exists, it is treated as an integer and added to else a new record is created with the provided value records are stored in binary format, and must be unpacked upon retrieval </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:close">RDB:close</a>&nbsp;()</td>
	<td class="summary">close remote database connection </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:copy">RDB:copy</a>&nbsp;(path)</td>
	<td class="summary">copy the database file to provided file path the db file will be kept in sync and not modified during copy </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:each">RDB:each</a>&nbsp;()</td>
	<td class="summary">iterate over each key-value pair in a database ( simple iterator; state is held in remote database ) </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:each_keys">RDB:each_keys</a>&nbsp;()</td>
	<td class="summary">iterate over each key in a database ( simple iterator; state is held in remote database ) </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:each_values">RDB:each_values</a>&nbsp;()</td>
	<td class="summary">iterate over each value in the database ( simple iterator; state is held in remote database ) </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:ext">RDB:ext</a>&nbsp;(name, key, val, opts)</td>
	<td class="summary">call a function of the server-side lua extension </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:fwmkeys">RDB:fwmkeys</a>&nbsp;(prefix, max)</td>
	<td class="summary">get forward matching keys note this will scan EVERY KEY in the database and may be  s l o w </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:get">RDB:get</a>&nbsp;(key)</td>
	<td class="summary">retrieve a record </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:has_key">RDB:has_key</a>&nbsp;(key)</td>
	<td class="summary">test for key </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:has_value">RDB:has_value</a>&nbsp;(val)</td>
	<td class="summary">test for value </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:is_empty">RDB:is_empty</a>&nbsp;()</td>
	<td class="summary">test if database is empty </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:iterinit">RDB:iterinit</a>&nbsp;()</td>
	<td class="summary">initialize the iterator (used to access the key of every record) </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:iternext">RDB:iternext</a>&nbsp;()</td>
	<td class="summary">get the next key of the iterator the iterator will traverse the database in arbitrary order [[ It is possible to access every record by iteration of calling this method.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:mget">RDB:mget</a>&nbsp;(recs)</td>
	<td class="summary">retrieve multiple records given a table containing an array of keys, add a hash of key-value pairs keys in the array with no corresponding value will be removed from the array ( understand that the table given is modified in place ) </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:misc">RDB:misc</a>&nbsp;(name, args, opts)</td>
	<td class="summary">call a versatile function for miscellaneous operations </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:new">RDB:new</a>&nbsp;()</td>
	<td class="summary">initialize a new Remote Database Object '__call'  metamethod of RDB </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:open">RDB:open</a>&nbsp;(host, port)</td>
	<td class="summary">open a remote database connection </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:optimize">RDB:optimize</a>&nbsp;(params)</td>
	<td class="summary">optimize storage according to provided tuning params </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:out">RDB:out</a>&nbsp;(key)</td>
	<td class="summary">remove a record </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:put">RDB:put</a>&nbsp;(key, val)</td>
	<td class="summary">store a record if a record with same key already exists then it is overwritten </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:putcat">RDB:putcat</a>&nbsp;(key, val)</td>
	<td class="summary">concatenate a value at the end of an existing record if no record with given key exists then create new record </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:putkeep">RDB:putkeep</a>&nbsp;(key, val)</td>
	<td class="summary">store a new record if record with same key exists then this has no effect </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:putnr">RDB:putnr</a>&nbsp;(key, val)</td>
	<td class="summary">store a record, with no response from the server if record with same key already exists then it is overwritten </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:putshl">RDB:putshl</a>&nbsp;(key, val, width)</td>
	<td class="summary">concatenate a value at the end of an existing record and shift it left by (length of concatenation result - provided width) if no record with given key exists then create new record </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:rnum">RDB:rnum</a>&nbsp;()</td>
	<td class="summary">get number of records ( limited to Lua's number type precision ) </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:size">RDB:size</a>&nbsp;()</td>
	<td class="summary">get size of database ( limited to Lua's number type precision ) </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:stat">RDB:stat</a>&nbsp;()</td>
	<td class="summary">get status string from remote database server ( string is in 'tab separated values' format ) </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:sync">RDB:sync</a>&nbsp;()</td>
	<td class="summary">synchronize updated contents with the file and device </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:vanish">RDB:vanish</a>&nbsp;()</td>
	<td class="summary">remove all records </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDB:vsiz">RDB:vsiz</a>&nbsp;(key)</td>
	<td class="summary">get the size of a record value </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDBQRY:addcond">RDBQRY:addcond</a>&nbsp;(name, op, expr)</td>
	<td class="summary">add a narrowing condition </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDBQRY:new">RDBQRY:new</a>&nbsp;(rdb)</td>
	<td class="summary">initialize a new query object '__call' metamethod for RDBQRY </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDBQRY:search">RDBQRY:search</a>&nbsp;()</td>
	<td class="summary">execute the search </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDBQRY:searchcount">RDBQRY:searchcount</a>&nbsp;()</td>
	<td class="summary">get the count of corresponding records </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDBQRY:searchget">RDBQRY:searchget</a>&nbsp;(names)</td>
	<td class="summary">get records corresponding to search due to protocol restriction, method cannot handle records with binary cols including the '\0' character </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDBQRY:searchout">RDBQRY:searchout</a>&nbsp;()</td>
	<td class="summary">remove each corresponding record </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDBQRY:setlimit">RDBQRY:setlimit</a>&nbsp;(max, skip)</td>
	<td class="summary">set maximum number of records for the result </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDBQRY:setorder">RDBQRY:setorder</a>&nbsp;(name, otype)</td>
	<td class="summary">set result order </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDBTBL:genuid">RDBTBL:genuid</a>&nbsp;()</td>
	<td class="summary">generate a unique id number </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDBTBL:get">RDBTBL:get</a>&nbsp;(pkey)</td>
	<td class="summary">retrieve a record </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDBTBL:mget">RDBTBL:mget</a>&nbsp;(recs)</td>
	<td class="summary">retrieve multiple records given a table containing an array of keys, add a hash of key-value pairs ( values being columns ) keys in the array with no corresponding value will be removed from the array ( understand that the table given is modified in place ) NOTE: due to protocol restriction, this method cannot handle records with binary columns including the "\0" character.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDBTBL:new">RDBTBL:new</a>&nbsp;()</td>
	<td class="summary">initialize a new Remote Table Database Object '__call' metamethod of RDBTBL </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDBTBL:out">RDBTBL:out</a>&nbsp;(pkey)</td>
	<td class="summary">remove a record </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDBTBL:put">RDBTBL:put</a>&nbsp;(pkey, cols)</td>
	<td class="summary">store a record ( overwrite if key exists ) </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDBTBL:putcat">RDBTBL:putcat</a>&nbsp;(pkey, cols)</td>
	<td class="summary">concatenate columns of an existing record or create a new record </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDBTBL:putkeep">RDBTBL:putkeep</a>&nbsp;(pkey, cols)</td>
	<td class="summary">store a record if key does not already exist, else do nothing </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#RDBTBL:setindex">RDBTBL:setindex</a>&nbsp;(name, itype)</td>
	<td class="summary">set a column index </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#strsplit">strsplit</a>&nbsp;(str, pat)</td>
	<td class="summary">Rici Lake's string splitter ( slightly modified so it doesn't get added to the global string table )-- </td>
	</tr>

</table>






<br/>
<br/>



<h2><a name="functions"></a>Functions</h2>
<dl class="function">



<dt><a name="RDB.keys"></a><strong>RDB.keys</strong>&nbsp;()</dt>
<dd>
return an array of all keys







<h3>Return value:</h3>
table



</dd>




<dt><a name="RDB.values"></a><strong>RDB.values</strong>&nbsp;()</dt>
<dd>
return an array of all values







<h3>Return value:</h3>
table



</dd>




<dt><a name="RDB:adddouble"></a><strong>RDB:adddouble</strong>&nbsp;(key, num)</dt>
<dd>
add a real number to a record if record exists, it is treated as a real number and added to else a new record is created with the provided value records are stored in binary format, and must be unpacked upon retrieval


<h3>Parameters</h3>
<ul>
	
	<li>
	  key: the record key
	</li>
	
	<li>
	  num: the additional value. (defaults to 0)
	</li>
	
</ul>






<h3>Return value:</h3>
sum or nil, error message



</dd>




<dt><a name="RDB:addint"></a><strong>RDB:addint</strong>&nbsp;(key, num)</dt>
<dd>
add an integer to a record if record exists, it is treated as an integer and added to else a new record is created with the provided value records are stored in binary format, and must be unpacked upon retrieval


<h3>Parameters</h3>
<ul>
	
	<li>
	  key: the record key
	</li>
	
	<li>
	  num: the additional value. (defaults to 0)
	</li>
	
</ul>






<h3>Return value:</h3>
sum or nil, error message



</dd>




<dt><a name="RDB:close"></a><strong>RDB:close</strong>&nbsp;()</dt>
<dd>
close remote database connection







<h3>Return value:</h3>
true or false, error message



</dd>




<dt><a name="RDB:copy"></a><strong>RDB:copy</strong>&nbsp;(path)</dt>
<dd>
copy the database file to provided file path the db file will be kept in sync and not modified during copy


<h3>Parameters</h3>
<ul>
	
	<li>
	  path: the file path to copy to if path begins with '@' then trailing substring is executed as command line
	</li>
	
</ul>






<h3>Return value:</h3>
true or false, error message



</dd>




<dt><a name="RDB:each"></a><strong>RDB:each</strong>&nbsp;()</dt>
<dd>
iterate over each key-value pair in a database ( simple iterator; state is held in remote database )







<h3>Return value:</h3>
function



</dd>




<dt><a name="RDB:each_keys"></a><strong>RDB:each_keys</strong>&nbsp;()</dt>
<dd>
iterate over each key in a database ( simple iterator; state is held in remote database )







<h3>Return value:</h3>
function



</dd>




<dt><a name="RDB:each_values"></a><strong>RDB:each_values</strong>&nbsp;()</dt>
<dd>
iterate over each value in the database ( simple iterator; state is held in remote database )







<h3>Return value:</h3>
function



</dd>




<dt><a name="RDB:ext"></a><strong>RDB:ext</strong>&nbsp;(name, key, val, opts)</dt>
<dd>
call a function of the server-side lua extension


<h3>Parameters</h3>
<ul>
	
	<li>
	  name: the function name
	</li>
	
	<li>
	  key: the key (defaults to empty string)
	</li>
	
	<li>
	  val: the value (defaults to empty string)
	</li>
	
	<li>
	  opts: options by bitwise-or option RDB.XOLCKREC = record locking option RDB.XOLCKGLB = global locking
	</li>
	
</ul>






<h3>Return value:</h3>
response or nil, error message



</dd>




<dt><a name="RDB:fwmkeys"></a><strong>RDB:fwmkeys</strong>&nbsp;(prefix, max)</dt>
<dd>
get forward matching keys note this will scan EVERY KEY in the database and may be  s l o w


<h3>Parameters</h3>
<ul>
	
	<li>
	  prefix: prefix of corresponding keys
	</li>
	
	<li>
	  max: max number of keys to fetch
	</li>
	
</ul>






<h3>Return value:</h3>
array of keys of corresponding records or {}, error message



</dd>




<dt><a name="RDB:get"></a><strong>RDB:get</strong>&nbsp;(key)</dt>
<dd>
retrieve a record


<h3>Parameters</h3>
<ul>
	
	<li>
	  key: the record key (coerced to string)
	</li>
	
</ul>






<h3>Return value:</h3>
record value or nil, error message



</dd>




<dt><a name="RDB:has_key"></a><strong>RDB:has_key</strong>&nbsp;(key)</dt>
<dd>
test for key


<h3>Parameters</h3>
<ul>
	
	<li>
	  key: key
	</li>
	
</ul>






<h3>Return value:</h3>
boolean



</dd>




<dt><a name="RDB:has_value"></a><strong>RDB:has_value</strong>&nbsp;(val)</dt>
<dd>
test for value


<h3>Parameters</h3>
<ul>
	
	<li>
	  val: value
	</li>
	
</ul>






<h3>Return value:</h3>
boolean



</dd>




<dt><a name="RDB:is_empty"></a><strong>RDB:is_empty</strong>&nbsp;()</dt>
<dd>
test if database is empty







<h3>Return value:</h3>
boolean



</dd>




<dt><a name="RDB:iterinit"></a><strong>RDB:iterinit</strong>&nbsp;()</dt>
<dd>
initialize the iterator (used to access the key of every record)







<h3>Return value:</h3>
true or false, error code



</dd>




<dt><a name="RDB:iternext"></a><strong>RDB:iternext</strong>&nbsp;()</dt>
<dd>
get the next key of the iterator the iterator will traverse the database in arbitrary order [[ It is possible to access every record by iteration of calling this method. It is allowed to update or remove records whose keys are fetched while the iteration. However, it is not assured if updating the database is occurred while the iteration. Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access. ]]--







<h3>Return value:</h3>
next key or nil, error message



</dd>




<dt><a name="RDB:mget"></a><strong>RDB:mget</strong>&nbsp;(recs)</dt>
<dd>
retrieve multiple records given a table containing an array of keys, add a hash of key-value pairs keys in the array with no corresponding value will be removed from the array ( understand that the table given is modified in place )


<h3>Parameters</h3>
<ul>
	
	<li>
	  recs: an array of keys
	</li>
	
</ul>






<h3>Return value:</h3>
number of retrieved records or -1, error message



</dd>




<dt><a name="RDB:misc"></a><strong>RDB:misc</strong>&nbsp;(name, args, opts)</dt>
<dd>
call a versatile function for miscellaneous operations


<h3>Parameters</h3>
<ul>
	
	<li>
	  name: one of 'putlist', 'getlist', or 'outlist' for any type of db or 'setindex', 'search', or 'genuid' for table db
	</li>
	
	<li>
	  args: an array containing arguments
	</li>
	
	<li>
	  opts: a bitmask containing options
	</li>
	
</ul>






<h3>Return value:</h3>
array of results or nil, error message



</dd>




<dt><a name="RDB:new"></a><strong>RDB:new</strong>&nbsp;()</dt>
<dd>
initialize a new Remote Database Object '__call'  metamethod of RDB





<h3>Usage:</h3>
tyr = require'tokyotyrant'; rdb = tyr.RDB(); rdb.open(host, port)



<h3>Return value:</h3>
new RDB Object



</dd>




<dt><a name="RDB:open"></a><strong>RDB:open</strong>&nbsp;(host, port)</dt>
<dd>
open a remote database connection


<h3>Parameters</h3>
<ul>
	
	<li>
	  host: the host string. (defaults to localhost)
	</li>
	
	<li>
	  port: the port number (number or string) (defaults to '1978')
	</li>
	
</ul>






<h3>Return value:</h3>
true or false, error message



</dd>




<dt><a name="RDB:optimize"></a><strong>RDB:optimize</strong>&nbsp;(params)</dt>
<dd>
optimize storage according to provided tuning params


<h3>Parameters</h3>
<ul>
	
	<li>
	  params: 
	</li>
	
</ul>






<h3>Return value:</h3>
true or false, error message



</dd>




<dt><a name="RDB:out"></a><strong>RDB:out</strong>&nbsp;(key)</dt>
<dd>
remove a record


<h3>Parameters</h3>
<ul>
	
	<li>
	  key: the record key (coerced to string)
	</li>
	
</ul>






<h3>Return value:</h3>
true or false, error message



</dd>




<dt><a name="RDB:put"></a><strong>RDB:put</strong>&nbsp;(key, val)</dt>
<dd>
store a record if a record with same key already exists then it is overwritten


<h3>Parameters</h3>
<ul>
	
	<li>
	  key: the record key (coerced to string)
	</li>
	
	<li>
	  val: the record value (coerced to string)
	</li>
	
</ul>






<h3>Return value:</h3>
true or false, error message



</dd>




<dt><a name="RDB:putcat"></a><strong>RDB:putcat</strong>&nbsp;(key, val)</dt>
<dd>
concatenate a value at the end of an existing record if no record with given key exists then create new record


<h3>Parameters</h3>
<ul>
	
	<li>
	  key: the record key (coerced to string)
	</li>
	
	<li>
	  val: the record value (coerced to string)
	</li>
	
</ul>






<h3>Return value:</h3>
true or false, error message



</dd>




<dt><a name="RDB:putkeep"></a><strong>RDB:putkeep</strong>&nbsp;(key, val)</dt>
<dd>
store a new record if record with same key exists then this has no effect


<h3>Parameters</h3>
<ul>
	
	<li>
	  key: the record key (coerced to string)
	</li>
	
	<li>
	  val: the record value (coerced to string)
	</li>
	
</ul>






<h3>Return value:</h3>
true or false, error message



</dd>




<dt><a name="RDB:putnr"></a><strong>RDB:putnr</strong>&nbsp;(key, val)</dt>
<dd>
store a record, with no response from the server if record with same key already exists then it is overwritten


<h3>Parameters</h3>
<ul>
	
	<li>
	  key: the record key (coerced to string)
	</li>
	
	<li>
	  val: the record value (coerced to string)
	</li>
	
</ul>






<h3>Return value:</h3>
true or false, error message



</dd>




<dt><a name="RDB:putshl"></a><strong>RDB:putshl</strong>&nbsp;(key, val, width)</dt>
<dd>
concatenate a value at the end of an existing record and shift it left by (length of concatenation result - provided width) if no record with given key exists then create new record


<h3>Parameters</h3>
<ul>
	
	<li>
	  key: the record key (coerced to string)
	</li>
	
	<li>
	  val: the record value (coerced to string)
	</li>
	
	<li>
	  width: the desired record length
	</li>
	
</ul>






<h3>Return value:</h3>
true or false, error message



</dd>




<dt><a name="RDB:rnum"></a><strong>RDB:rnum</strong>&nbsp;()</dt>
<dd>
get number of records ( limited to Lua's number type precision )







<h3>Return value:</h3>
record number or 0, error message



</dd>




<dt><a name="RDB:size"></a><strong>RDB:size</strong>&nbsp;()</dt>
<dd>
get size of database ( limited to Lua's number type precision )







<h3>Return value:</h3>
record size or 0, error message



</dd>




<dt><a name="RDB:stat"></a><strong>RDB:stat</strong>&nbsp;()</dt>
<dd>
get status string from remote database server ( string is in 'tab separated values' format )







<h3>Return value:</h3>
status string or nil, error message



</dd>




<dt><a name="RDB:sync"></a><strong>RDB:sync</strong>&nbsp;()</dt>
<dd>
synchronize updated contents with the file and device







<h3>Return value:</h3>
true or false, error message



</dd>




<dt><a name="RDB:vanish"></a><strong>RDB:vanish</strong>&nbsp;()</dt>
<dd>
remove all records







<h3>Return value:</h3>
true or false, error message



</dd>




<dt><a name="RDB:vsiz"></a><strong>RDB:vsiz</strong>&nbsp;(key)</dt>
<dd>
get the size of a record value


<h3>Parameters</h3>
<ul>
	
	<li>
	  key: the record key (coerced to string)
	</li>
	
</ul>






<h3>Return value:</h3>
size or -1, error message



</dd>




<dt><a name="RDBQRY:addcond"></a><strong>RDBQRY:addcond</strong>&nbsp;(name, op, expr)</dt>
<dd>
add a narrowing condition


<h3>Parameters</h3>
<ul>
	
	<li>
	  name: specifies a column name. empty string indicates the primary key.
	</li>
	
	<li>
	  op: specifies an operation type: QCSTREQ = 0,   --string is equal to QCSTRINC = 1,  --string is included in QCSTRBW = 2,   --string begins with QCSTREW = 3,   --string ends with QCSTRAND = 4,  --string includes all tokens in QCSTROR = 5,   --string includes at least one token in QCSTROREQ = 6, --string is equal to at least one token in QCSTRRX = 7,   --string matches regular expressions of QCNUMEQ = 8,   --number is equal to QCNUMGT = 9,   --number is greater than QCNUMGE = 10,  --number is greater than or equal to QCNUMLT = 11,  --number is less than QCNUMLE = 12,  --number is less than or equal to QCNUMBT = 13,  --number is between two tokens of QCNUMOREQ = 14,--number is equal to at least one token in QCFTSPH = 15,  --full-text search with the phrase of QCFTSAND = 16, --full-text search with all tokens in QCFTSOR = 17,  --full-text search with at least one token in QCFTSEX = 18,  --f-text search with the compound expression of all ops can be flagged by bitwise-or: QCNEGATE = shl(1,24), --negation flag QCNOIDX = shl(1,25),  --no index flag
	</li>
	
	<li>
	  expr: 
	</li>
	
</ul>






<h3>Return value:</h3>
nil



</dd>




<dt><a name="RDBQRY:new"></a><strong>RDBQRY:new</strong>&nbsp;(rdb)</dt>
<dd>
initialize a new query object '__call' metamethod for RDBQRY


<h3>Parameters</h3>
<ul>
	
	<li>
	  rdb: 
	</li>
	
</ul>






<h3>Return value:</h3>
new RDBQRY object



</dd>




<dt><a name="RDBQRY:search"></a><strong>RDBQRY:search</strong>&nbsp;()</dt>
<dd>
execute the search







<h3>Return value:</h3>
array of primary keys of corresponding records or {}, error message



</dd>




<dt><a name="RDBQRY:searchcount"></a><strong>RDBQRY:searchcount</strong>&nbsp;()</dt>
<dd>
get the count of corresponding records







<h3>Return value:</h3>
count or 0, error message



</dd>




<dt><a name="RDBQRY:searchget"></a><strong>RDBQRY:searchget</strong>&nbsp;(names)</dt>
<dd>
get records corresponding to search due to protocol restriction, method cannot handle records with binary cols including the '\0' character


<h3>Parameters</h3>
<ul>
	
	<li>
	  names: specifies an array of colum names to fetch. empty string means the primary key nil means fetch every column
	</li>
	
</ul>






<h3>Return value:</h3>
array of column hashes of corresponding records or {}, error message



</dd>




<dt><a name="RDBQRY:searchout"></a><strong>RDBQRY:searchout</strong>&nbsp;()</dt>
<dd>
remove each corresponding record







<h3>Return value:</h3>
true or false, error message



</dd>




<dt><a name="RDBQRY:setlimit"></a><strong>RDBQRY:setlimit</strong>&nbsp;(max, skip)</dt>
<dd>
set maximum number of records for the result


<h3>Parameters</h3>
<ul>
	
	<li>
	  max: the maximum number of records. nil or negative means no limit
	</li>
	
	<li>
	  skip: the number of skipped records. nil or !>0 means none skipped
	</li>
	
</ul>






<h3>Return value:</h3>
nil



</dd>




<dt><a name="RDBQRY:setorder"></a><strong>RDBQRY:setorder</strong>&nbsp;(name, otype)</dt>
<dd>
set result order


<h3>Parameters</h3>
<ul>
	
	<li>
	  name: specifies column name. empty string indicates the primary key.
	</li>
	
	<li>
	  otype: specifies the order type: QOSTRASC = 0, --string ascending QOSTRDESC = 1,--string descending QONUMASC = 2, --number ascending QONUMDESC = 3,--number descending
	</li>
	
</ul>






<h3>Return value:</h3>
nil



</dd>




<dt><a name="RDBTBL:genuid"></a><strong>RDBTBL:genuid</strong>&nbsp;()</dt>
<dd>
generate a unique id number







<h3>Return value:</h3>
unique id number or -1, error message



</dd>




<dt><a name="RDBTBL:get"></a><strong>RDBTBL:get</strong>&nbsp;(pkey)</dt>
<dd>
retrieve a record


<h3>Parameters</h3>
<ul>
	
	<li>
	  pkey: the primary key
	</li>
	
</ul>






<h3>Return value:</h3>
a table of columns



</dd>




<dt><a name="RDBTBL:mget"></a><strong>RDBTBL:mget</strong>&nbsp;(recs)</dt>
<dd>
retrieve multiple records given a table containing an array of keys, add a hash of key-value pairs ( values being columns ) keys in the array with no corresponding value will be removed from the array ( understand that the table given is modified in place ) NOTE: due to protocol restriction, this method cannot handle records with binary columns including the "\0" character.


<h3>Parameters</h3>
<ul>
	
	<li>
	  recs: an array of keys
	</li>
	
</ul>






<h3>Return value:</h3>
number of retrieved records or -1, error message



</dd>




<dt><a name="RDBTBL:new"></a><strong>RDBTBL:new</strong>&nbsp;()</dt>
<dd>
initialize a new Remote Table Database Object '__call' metamethod of RDBTBL







<h3>Return value:</h3>
new RDBTBL Object



</dd>




<dt><a name="RDBTBL:out"></a><strong>RDBTBL:out</strong>&nbsp;(pkey)</dt>
<dd>
remove a record


<h3>Parameters</h3>
<ul>
	
	<li>
	  pkey: the primary key
	</li>
	
</ul>






<h3>Return value:</h3>
true or false, error message



</dd>




<dt><a name="RDBTBL:put"></a><strong>RDBTBL:put</strong>&nbsp;(pkey, cols)</dt>
<dd>
store a record ( overwrite if key exists )


<h3>Parameters</h3>
<ul>
	
	<li>
	  pkey: the primary key
	</li>
	
	<li>
	  cols: table of columns
	</li>
	
</ul>






<h3>Return value:</h3>
true or false, error message



</dd>




<dt><a name="RDBTBL:putcat"></a><strong>RDBTBL:putcat</strong>&nbsp;(pkey, cols)</dt>
<dd>
concatenate columns of an existing record or create a new record


<h3>Parameters</h3>
<ul>
	
	<li>
	  pkey: primary key
	</li>
	
	<li>
	  cols: a table of columns
	</li>
	
</ul>






<h3>Return value:</h3>
true or false, error message



</dd>




<dt><a name="RDBTBL:putkeep"></a><strong>RDBTBL:putkeep</strong>&nbsp;(pkey, cols)</dt>
<dd>
store a record if key does not already exist, else do nothing


<h3>Parameters</h3>
<ul>
	
	<li>
	  pkey: the primary key
	</li>
	
	<li>
	  cols: a table of columns
	</li>
	
</ul>






<h3>Return value:</h3>
true or false, error message



</dd>




<dt><a name="RDBTBL:setindex"></a><strong>RDBTBL:setindex</strong>&nbsp;(name, itype)</dt>
<dd>
set a column index


<h3>Parameters</h3>
<ul>
	
	<li>
	  name: the column name. if the name of an existing index is specified, then the index is rebuilt. an empty string means the primary key.
	</li>
	
	<li>
	  itype: the index type: `TokyoTyrant::RDBTBL::ITLEXICAL' for lexical string, `TokyoTyrant::RDBTBL::ITDECIMAL' for decimal string, `TokyoTyrant::RDBTBL::ITTOKEN' for token inverted index, `TokyoTyrant::RDBTBL::ITQGRAM' for q-gram inverted index, `TokyoTyrant::RDBTBL::ITOPT' will optimize the index, `TokyoTyrant::RDBTBL::ITVOID' will remove the index, `TokyoTyrant::RDBTBL::ITKEEP', if added by bitwise OR and the index exists, will merely return failure.
	</li>
	
</ul>






<h3>Return value:</h3>
true or false



</dd>




<dt><a name="strsplit"></a><strong>strsplit</strong>&nbsp;(str, pat)</dt>
<dd>
Rici Lake's string splitter ( slightly modified so it doesn't get added to the global string table )--


<h3>Parameters</h3>
<ul>
	
	<li>
	  str: 
	</li>
	
	<li>
	  pat: 
	</li>
	
</ul>








</dd>


</dl>






</div> <!-- id="content" -->

</div> <!-- id="main" -->

<div id="about">
	<p><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0!" height="31" width="88" /></a></p>
</div> <!-- id="about" -->

</div> <!-- id="container" -->	
</body>
</html>
